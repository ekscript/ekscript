{"version":3,"file":"export.js","sourceRoot":"","sources":["../../../../src/lib/converter/nodes/export.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\n\nimport {\n    Reflection,\n    ReflectionFlag,\n    DeclarationReflection,\n    ContainerReflection\n} from '../../models/index';\nimport { Context } from '../context';\nimport { Component, ConverterNodeComponent } from '../components';\nimport { createReferenceReflection } from '../factories/reference';\nimport { SourceFileMode } from '../../utils';\n\n@Component({ name: 'node:export' })\nexport class ExportConverter extends ConverterNodeComponent<\n    ts.ExportAssignment\n> {\n    /**\n     * List of supported TypeScript syntax kinds.\n     */\n    supports: ts.SyntaxKind[] = [ts.SyntaxKind.ExportAssignment];\n\n    convert(context: Context, node: ts.ExportAssignment): Reflection {\n        let symbol: ts.Symbol | undefined;\n\n        // default export\n        if (\n            node.symbol &&\n            (node.symbol.flags & ts.SymbolFlags.Alias) === ts.SymbolFlags.Alias\n        ) {\n            symbol = context.checker.getAliasedSymbol(node.symbol);\n        } else {\n            let type = context.getTypeAtLocation(node.expression);\n            symbol = type ? type.symbol : undefined;\n        }\n        if (symbol && symbol.declarations) {\n            const project = context.project;\n            symbol.declarations.forEach((declaration) => {\n                if (!declaration.symbol) {\n                    return;\n                }\n\n                const reflection = project.getReflectionFromFQN(\n                    context.checker.getFullyQualifiedName(declaration.symbol)\n                );\n                if (\n                    node.isExportEquals &&\n                    reflection instanceof DeclarationReflection\n                ) {\n                    reflection.setFlag(ReflectionFlag.ExportAssignment, true);\n                }\n                if (reflection) {\n                    markAsExported(reflection);\n                }\n            });\n        }\n\n        function markAsExported(reflection: Reflection) {\n            if (reflection instanceof DeclarationReflection) {\n                reflection.setFlag(ReflectionFlag.Exported, true);\n            }\n\n            reflection.traverse(markAsExported);\n        }\n\n        return context.scope;\n    }\n}\n\n@Component({ name: 'node:export-declaration' })\nexport class ExportDeclarationConverter extends ConverterNodeComponent<\n    ts.ExportDeclaration\n> {\n    supports = [ts.SyntaxKind.ExportDeclaration];\n\n    convert(\n        context: Context,\n        node: ts.ExportDeclaration\n    ): Reflection | undefined {\n        const withinNamespace = node.parent.kind === ts.SyntaxKind.ModuleBlock;\n\n        // It doesn't make sense to convert export declarations if we are pretending everything is global.\n        if (\n            this.application.options.getValue('mode') === SourceFileMode.File &&\n            !withinNamespace\n        ) {\n            return;\n        }\n\n        const scope = context.scope;\n        if (!(scope instanceof ContainerReflection)) {\n            throw new Error('Expected to be within a container');\n        }\n\n        if (\n            node.exportClause &&\n            node.exportClause.kind === ts.SyntaxKind.NamedExports\n        ) {\n            // export { a, a as b }\n            node.exportClause.elements.forEach((specifier) => {\n                const source = context.expectSymbolAtLocation(specifier.name);\n                const target = context.resolveAliasedSymbol(\n                    context.expectSymbolAtLocation(\n                        specifier.propertyName ?? specifier.name\n                    )\n                );\n                // If the original declaration is in this file, export {} was used with something\n                // defined in this file and we don't need to create a reference unless the name is different.\n                if (\n                    !node.moduleSpecifier &&\n                    !specifier.propertyName &&\n                    !withinNamespace\n                ) {\n                    return;\n                }\n\n                createReferenceReflection(context, source, target);\n            });\n        } else if (\n            node.exportClause &&\n            node.exportClause.kind === ts.SyntaxKind.NamespaceExport\n        ) {\n            // export * as ns from ...\n            const source = context.expectSymbolAtLocation(\n                node.exportClause.name\n            );\n            if (!node.moduleSpecifier) {\n                throw new Error(\n                    'Namespace export is missing a module specifier.'\n                );\n            }\n            const target = context.resolveAliasedSymbol(\n                context.expectSymbolAtLocation(node.moduleSpecifier)\n            );\n            createReferenceReflection(context, source, target);\n        } else if (node.moduleSpecifier) {\n            // export * from ...\n            const sourceFileSymbol = context.expectSymbolAtLocation(\n                node.moduleSpecifier\n            );\n            for (const symbol of context.checker.getExportsOfModule(\n                sourceFileSymbol\n            )) {\n                if (symbol.name === 'default') {\n                    // Default exports are not re-exported with export *\n                    continue;\n                }\n                createReferenceReflection(\n                    context,\n                    symbol,\n                    context.resolveAliasedSymbol(symbol)\n                );\n            }\n        }\n\n        return context.scope;\n    }\n}\n"]}