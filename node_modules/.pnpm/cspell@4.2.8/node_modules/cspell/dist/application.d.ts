/// <reference types="node" />
import * as minimatch from 'minimatch';
import * as cspell from 'cspell-lib';
import { TraceResult, CheckTextInfo } from 'cspell-lib';
export { TraceResult, IncludeExcludeFlag } from 'cspell-lib';
import { GlobMatcher } from 'cspell-glob';
export interface CSpellApplicationOptions extends BaseOptions {
    /**
     * Display verbose information
     */
    verbose?: boolean;
    /**
     * Show extensive output.
     */
    debug?: boolean;
    /**
     * a glob to exclude files from being checked.
     */
    exclude?: string;
    /**
     * Only report the words, no line numbers or file names.
     */
    wordsOnly?: boolean;
    /**
     * unique errors per file only.
     */
    unique?: boolean;
    /**
     * root directory, defaults to `cwd`
     */
    root?: string;
}
export declare type TraceOptions = BaseOptions;
export interface BaseOptions {
    config?: string;
    languageId?: string;
    local?: string;
}
export declare type AppError = NodeJS.ErrnoException;
export interface RunResult {
    files: number;
    filesWithIssues: Set<string>;
    issues: number;
    errors: number;
}
export declare type Issue = cspell.TextDocumentOffset;
export interface GlobSrcInfo {
    matcher: GlobMatcher;
    source: string;
}
export declare type MessageType = 'Debug' | 'Info' | 'Progress';
export declare type MessageTypeLookup = {
    [key in MessageType]: key;
};
export declare const MessageTypes: MessageTypeLookup;
export interface MessageEmitter {
    (message: string, msgType: MessageType): void;
}
export interface DebugEmitter {
    (message: string): void;
}
export interface ErrorEmitterVoid {
    (message: string, error: Error): void;
}
export interface ErrorEmitterPromise {
    (message: string, error: Error): Promise<void>;
}
declare type ErrorEmitter = ErrorEmitterVoid | ErrorEmitterPromise;
export interface SpellingErrorEmitter {
    (issue: Issue): void;
}
export interface Emitters {
    issue: SpellingErrorEmitter;
    info: MessageEmitter;
    debug: DebugEmitter;
    error: ErrorEmitter;
}
interface GlobOptions extends minimatch.IOptions {
    cwd?: string;
    root?: string;
}
export declare class CSpellApplicationConfiguration {
    readonly files: string[];
    readonly options: CSpellApplicationOptions;
    readonly emitters: Emitters;
    readonly info: MessageEmitter;
    readonly debug: DebugEmitter;
    readonly logIssue: SpellingErrorEmitter;
    readonly uniqueFilter: (issue: Issue) => boolean;
    readonly local: string;
    readonly configFile: string | undefined;
    readonly configGlob: string;
    readonly configGlobOptions: minimatch.IOptions;
    readonly excludes: GlobSrcInfo[];
    readonly root: string;
    constructor(files: string[], options: CSpellApplicationOptions, emitters: Emitters);
}
export declare function lint(files: string[], options: CSpellApplicationOptions, emitters: Emitters): Promise<RunResult>;
export declare function trace(words: string[], options: TraceOptions): Promise<TraceResult[]>;
export declare type CheckTextResult = CheckTextInfo;
export declare function checkText(filename: string, options: BaseOptions): Promise<CheckTextResult>;
export declare function createInit(_: CSpellApplicationOptions): Promise<void>;
/**
 * Looks for matching glob patterns or stdin
 * @param globPatterns patterns or stdin
 */
declare function findFiles(globPatterns: string[], options: GlobOptions): Promise<string[]>;
interface PatternRoot {
    pattern: string;
    root: string;
}
/**
 * Attempt to normalize a pattern based upon the root.
 * If the pattern is absolute, check to see if it exists and adjust the root, otherwise it is assumed to be based upon the current root.
 * If the pattern starts with a relative path, adjust the root to match.
 * The challenge is with the patterns that begin with `/`. Is is an absolute path or relative pattern?
 * @param pat glob pattern
 * @param root absolute path | empty
 * @returns the adjusted root and pattern.
 */
declare function normalizePattern(pat: string, root: string): PatternRoot;
declare function _globP(pattern: string, options: GlobOptions): Promise<string[]>;
export declare const _testing_: {
    _globP: typeof _globP;
    findFiles: typeof findFiles;
    normalizePattern: typeof normalizePattern;
};
