import { Sequence } from 'gensequence';
import { TrieNode } from './TrieNode';
import { SuggestionCollector, SuggestionResult, CompoundWordsMethod } from './suggest';
import { WalkerIterator } from './walker';
export interface TrieOptions {
    compoundCharacter: string;
    stripCaseAndAccentsPrefix: string;
    forbiddenWordPrefix: string;
}
export declare const defaultTrieOptions: TrieOptions;
declare type Optional<T> = {
    [key in keyof T]?: T[key];
};
declare type PartialTrieOptions = Optional<TrieOptions> | undefined;
export declare class Trie {
    readonly root: TrieNode;
    private count?;
    private _options;
    constructor(root: TrieNode, count?: number | undefined, options?: PartialTrieOptions);
    /**
     * Number of words in the Trie
     */
    size(): number;
    get options(): TrieOptions;
    find(text: string, minCompoundLength?: boolean | number): TrieNode | undefined;
    findCompound(text: string, minCompoundLength?: number, minLength?: number): TrieNode | undefined;
    findExact(text: string): TrieNode | undefined;
    has(word: string, minCompoundLength?: boolean | number): boolean;
    /**
     * Provides an ordered sequence of words with the prefix of text.
     */
    completeWord(text: string): Sequence<string>;
    /**
     * Suggest spellings for `text`.  The results are sorted by edit distance with changes near the beginning of a word having a greater impact.
     * @param text - the text to search for
     * @param maxNumSuggestions - the maximum number of suggestions to return.
     * @param compoundMethod - Use to control splitting words.
     * @param numChanges - the maximum number of changes allowed to text. This is an approximate value, since some changes cost less than others.
     *                      the lower the value, the faster results are returned. Values less than 4 are best.
     */
    suggest(text: string, maxNumSuggestions: number, compoundMethod?: CompoundWordsMethod, numChanges?: number): string[];
    /**
     * Suggest spellings for `text`.  The results are sorted by edit distance with changes near the beginning of a word having a greater impact.
     * The results include the word and adjusted edit cost.  This is useful for merging results from multiple tries.
     */
    suggestWithCost(text: string, maxNumSuggestions: number, compoundMethod?: CompoundWordsMethod, numChanges?: number): SuggestionResult[];
    /**
     * genSuggestions will generate suggestions and send them to `collector`. `collector` is responsible for returning the max acceptable cost.
     * Costs are measured in weighted changes. A cost of 100 is the same as 1 edit. Some edits are considered cheaper.
     * Returning a MaxCost < 0 will effectively cause the search for suggestions to stop.
     */
    genSuggestions(collector: SuggestionCollector, compoundMethod?: CompoundWordsMethod): void;
    /**
     * Returns an iterator that can be used to get all words in the trie. For some dictionaries, this can result in millions of words.
     */
    words(): Sequence<string>;
    /**
     * Allows iteration over the entire tree.
     * On the returned Iterator, calling .next(goDeeper: boolean), allows for controlling the depth.
     */
    iterate(): WalkerIterator;
    insert(word: string): this;
    static create(words: Iterable<string> | IterableIterator<string>, options?: PartialTrieOptions): Trie;
}
export {};
