"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
exports.__esModule = true;
var fs = require("fs");
var pathlib = require("path");
var Printer = /** @class */ (function () {
    function Printer() {
        this.indentation = '';
    }
    Printer.prototype.indent = function () {
        this.indentation += '  ';
        return this;
    };
    Printer.prototype.deindent = function () {
        this.indentation = this.indentation.substring(0, this.indentation.length - 2);
        return this;
    };
    Printer.prototype.println = function (str) {
        if (str == null) {
            console.log();
        }
        else {
            console.log(this.indentation + str);
        }
        return this;
    };
    Printer.prototype.printEach = function (items) {
        if (items == null)
            return this;
        for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
            var item = items_1[_i];
            if (item == null)
                continue;
            this.println(item);
        }
        return this;
    };
    Printer.prototype.forEach = function (items, fn) {
        if (items == null)
            return this;
        for (var _i = 0, items_2 = items; _i < items_2.length; _i++) {
            var item = items_2[_i];
            if (item == null)
                continue;
            fn(item, this);
        }
        return this;
    };
    Printer.prototype.forEachInRecord = function (items, fn) {
        if (items == null)
            return this;
        for (var _i = 0, _a = Object.keys(items); _i < _a.length; _i++) {
            var key = _a[_i];
            var item = items[key];
            if (item == null)
                continue;
            fn(key, item, this);
        }
        return this;
    };
    return Printer;
}());
function isIdentifier(str) {
    return /^[a-z$_][a-z0-9$_]*$/i.test(str);
}
function mangleNameToIdentifier(str) {
    var sb = '$';
    for (var i = 0; i < str.length; ++i) {
        var char = str.charAt(i);
        if (/[a-z0-9_]/i.test(char)) {
            sb += char;
        }
        else {
            sb += '$' + str.charCodeAt(i) + '$';
        }
    }
    return sb;
}
function toCapitalCase(str) {
    return str.replace(/^[a-z]/, function (t) { return t.toUpperCase(); })
        .replace(/_[a-zA-Z]/g, function (t) { return t.substring(1).toUpperCase(); });
}
function getTypePrefixFromString(str) {
    return isIdentifier(str) ? toCapitalCase(str) : mangleNameToIdentifier(str);
}
function getTypeNameFromString(str) {
    return getTypePrefixFromString(str) + 'Node';
}
function getSyntaxKindFromString(str) {
    return getTypePrefixFromString(str);
}
function getTypeExprFromRef(ref, index) {
    if (ref.isError) {
        return 'ErrorNode';
    }
    if (!ref.named) {
        var name_1 = index.typeNames.get(ref.type);
        var arg = name_1 != null ? "SyntaxType." + name_1 : JSON.stringify(ref.type);
        return "UnnamedNode<" + arg + ">";
    }
    return getTypeNameFromString(ref.type);
}
function buildIndex(json) {
    var typeNames = new Map();
    for (var _i = 0, json_1 = json; _i < json_1.length; _i++) {
        var entry = json_1[_i];
        if (entry.named) {
            var name_2 = getSyntaxKindFromString(entry.type);
            typeNames.set(entry.type, name_2);
        }
    }
    return { typeNames: typeNames };
}
function generatePreamble(json, printer) {
    printer.println("\ninterface NamedNodeBase extends SyntaxNodeBase {\n    isNamed: true;\n}\n\n/** An unnamed node with the given type string. */\nexport interface UnnamedNode<T extends string = string> extends SyntaxNodeBase {\n  type: T;\n  isNamed: false;\n}\n\ntype PickNamedType<Node, T extends string> = Node extends { type: T; isNamed: true } ? Node : never;\n\ntype PickType<Node, T extends string> = Node extends { type: T } ? Node : never;\n\n/** A named node with the given `type` string. */\nexport type NamedNode<T extends SyntaxType = SyntaxType> = PickNamedType<SyntaxNode, T>;\n\n/**\n * A node with the given `type` string.\n *\n * Note that this matches both named and unnamed nodes. Use `NamedNode<T>` to pick only named nodes.\n */\nexport type NodeOfType<T extends string> = PickType<SyntaxNode, T>;\n\ninterface TreeCursorOfType<S extends string, T extends SyntaxNodeBase> {\n  nodeType: S;\n  currentNode: T;\n}\n\ntype TreeCursorRecord = { [K in TypeString]: TreeCursorOfType<K, NodeOfType<K>> };\n\n/**\n * A tree cursor whose `nodeType` correlates with `currentNode`.\n *\n * The typing becomes invalid once the underlying cursor is mutated.\n *\n * The intention is to cast a `TreeCursor` to `TypedTreeCursor` before\n * switching on `nodeType`.\n *\n * For example:\n * ```ts\n * let cursor = root.walk();\n * while (cursor.gotoNextSibling()) {\n *   const c = cursor as TypedTreeCursor;\n *   switch (c.nodeType) {\n *     case SyntaxType.Foo: {\n *       let node = c.currentNode; // Typed as FooNode.\n *       break;\n *     }\n *   }\n * }\n * ```\n */\nexport type TypedTreeCursor = TreeCursorRecord[keyof TreeCursorRecord];\n\nexport interface ErrorNode extends NamedNodeBase {\n    type: SyntaxType.ERROR;\n    hasError(): true;\n}\n");
}
function generateTypeEnum(json, _a, printer) {
    var typeNames = _a.typeNames;
    printer.
        println('export const enum SyntaxType {')
        .indent()
        .println('ERROR = "ERROR",')
        .forEach(json, function (entry) {
        if (entry.named && (entry.subtypes == null || entry.subtypes.length === 0)) {
            var name_3 = getSyntaxKindFromString(entry.type);
            printer.println(name_3 + " = " + JSON.stringify(entry.type) + ",");
        }
    })
        .deindent()
        .println('}')
        .println()
        .println('export type UnnamedType =')
        .indent()
        .forEach(json, function (entry) {
        if (!entry.named) {
            var name_4 = typeNames.get(entry.type);
            if (name_4 != null) {
                printer.println("| SyntaxType." + name_4 + " // both named and unnamed");
            }
            else {
                printer.println("| " + JSON.stringify(entry.type));
            }
        }
    })
        .println(';')
        .deindent()
        .println()
        .println('export type TypeString = SyntaxType | UnnamedType;')
        .println();
}
function generateNamedDeclaration(entry, index, printer) {
    if (!entry.named)
        return;
    if (entry.subtypes != null && entry.subtypes.length > 0) {
        generateUnionFromEntry(entry, index, printer);
    }
    else {
        generateInterfaceFromEntry(entry, index, printer);
    }
}
function generateInterfaceFromEntry(entry, index, printer) {
    var kind = getSyntaxKindFromString(entry.type);
    var name = getTypeNameFromString(entry.type);
    printer
        .println("export interface " + name + " extends NamedNodeBase {")
        .indent()
        .println("type: SyntaxType." + kind + ";")
        .forEachInRecord(entry.fields, function (field, children) {
        var fieldName = field + 'Node';
        var type = children.types.map(function (t) { return getTypeExprFromRef(t, index); }).join(' | ');
        if (type === '') {
            type = 'UnnamedNode';
        }
        if (children.multiple) {
            if (children.types.length > 1) {
                type = '(' + type + ')';
            }
            type += '[]';
            fieldName += 's';
        }
        var opt = (children.required || children.multiple) ? '' : '?';
        printer.println("" + fieldName + opt + ": " + type + ";");
    })
        .deindent()
        .println('}')
        .println();
}
function generateUnionFromEntry(entry, index, printer) {
    generateUnion(getTypeNameFromString(entry.type), entry.subtypes, index, printer);
}
function generateRootUnion(json, index, printer) {
    var errorType = { type: 'ERROR', named: true, isError: true };
    generateUnion('SyntaxNode', __spreadArrays(json, [errorType]), index, printer);
}
function generateUnion(name, members, index, printer) {
    printer
        .println("export type " + name + " = ")
        .indent()
        .forEach(members, function (ref) {
        printer.println('| ' + getTypeExprFromRef(ref, index));
    })
        .println(';')
        .deindent()
        .println();
}
function generateModifiedTreeSitterDts(json, dtsText, printer) {
    var text = dtsText
        .replace(/declare module ['"]tree-sitter['"] {(.*)}/s, function (str, p1) { return p1.replace(/^  /gm, ''); })
        .replace('export = Parser', '')
        .replace(/namespace Parser {(.*)}/s, function (str, p1) { return p1.replace(/^  /gm, ''); })
        .replace(/^\s*(class|interface|namespace)/gm, 'export $1')
        .replace(/\bexport class\b/g, 'export interface')
        .replace(/\bParser\.(\w+)\b/g, "$1")
        .replace('export interface SyntaxNode', 'interface SyntaxNodeBase')
        .replace(/closest\(\w+:.*\): SyntaxNode \| null;/, 'closest<T extends SyntaxType>(types: T | readonly T[]): NamedNode<T> | null;')
        .replace(/descendantsOfType\(types: [^,]*, (.*)\): Array<SyntaxNode>;/, 'descendantsOfType<T extends TypeString>(types: T | readonly T[], $1): NodeOfType<T>[];')
        .replace(/\n\n\n+/g, '\n\n')
        .replace(/\n+$/, '');
    printer.println(text);
}
var usageText = "\n  Usage: dts-tree-sitter INPUT > OUTPUT.d.ts\n\n  Generates a .d.ts file to stdout.\n";
function fileExists(file) {
    try {
        return fs.statSync(file).isFile();
    }
    catch (e) {
        return false;
    }
}
function getLookupLocations(input) {
    var result = [
        input,
        pathlib.join(input, 'node-types.json'),
        pathlib.join(input, 'src/node-types.json'),
    ];
    if (!input.startsWith('.')) {
        result.push(pathlib.join('node_modules', input, 'src/node-types.json'));
    }
    return result;
}
function getTreeSitterDts() {
    var entryPoint = require.resolve('tree-sitter');
    var packageDir = pathlib.dirname(entryPoint);
    var file = pathlib.join(packageDir, 'tree-sitter.d.ts');
    return fs.readFileSync(file, 'utf8');
}
function main() {
    var args = process.argv.slice(2);
    if (args.length !== 1) {
        console.error(usageText);
        process.exit(1);
    }
    var locations = getLookupLocations(args[0]);
    var filename = locations.find(fileExists);
    var treeSitterDtsText = getTreeSitterDts();
    if (filename == null) {
        console.error("Could not find node-types.json at any of the following locations:");
        locations.forEach(function (l) { return console.log("  " + l); });
        process.exit(1);
    }
    var json = JSON.parse(fs.readFileSync(filename, 'utf8'));
    var index = buildIndex(json);
    var printer = new Printer();
    generateModifiedTreeSitterDts(json, treeSitterDtsText, printer);
    generatePreamble(json, printer);
    generateTypeEnum(json, index, printer);
    generateRootUnion(json, index, printer);
    printer.forEach(json, function (t) { return generateNamedDeclaration(t, index, printer); });
}
main();
